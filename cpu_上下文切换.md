# cpu上下文切换

1. 什么是cpu上下文切换以及上下文切换的场景有哪些

- cpu上下文切换
```
CPU 上下文切换，就是先把前一个任务的 CPU 上下文（也就是 CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下文到寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务
而这些保存下来的上下文，会存储在系统内核中，并在任务重新调度执行时再次加载进来。这样就能保证任务原来的状态不受影响，让任务看起来还是连续运行
```
- 场景
```
- 进程上下文切换
- 线程上下文切换
- 中断上下文切换
```
# 进程上下文切换(一个进程切换到另一个进程运行)
```
进程的运行空间有 内核空间、用户空间 两种；其中用户空间，不能直接访问内存等其他硬件设备，必须通过系统调用载入到内核空间中才能访问内核空间的资源
也就是说，进程既可以在用户空间运行，称之为进程的用户态
又可以在内核空间运行，称之为进程的内核态
两者的转变，是需要通过系统调用来完成

比如查看已文件，首先调用open() 函数打开文件，其次调用read()函数读取文件内容，最后调用 write()函数将内容打印到stdout，最最后再调用close()函数关闭文件
以上系统调用，均是在一个进程运行，所以系统的调用我们成为特权模式切换，而不是上下文切换，但实际上上下文切换也是无法避免的，也就是说在整个调用的过程中，必然会发生CPU的上下文切换

那进程上下文切换 与 系统调用的区别是什么？

系统调用只是会调用不同函数完成进程的需求，而进程上下文切换需要保存当前进程内核状态和cpu寄存器，也会把该进程的虚拟内存，栈等其它保存下来，从而加载下一进程的内核态后，而且也要刷新进程的虚拟内存和用户栈
所以保存上下文以及恢复上下文的过程是有资源消耗的，在大量的进程上下文切换过程，肯定会大量的消耗系统资源，好在进程的切换大部分都是几十纳秒和数微秒级别，所以切换时间还是相当可观的

既然知道了上下文切换可能会导致系统负载较高，那我们需要知道什么时候会发生上下文切换，进程的切换就会有cpu上下文的切换，那么只有在进程调度时才需要上下文切换，而linux为每个cpu维护了一个就绪队列，
其中主要是正在运行和正在等待cpu的进程(活跃进程)，它们会按照优先级和等待cpu的时间进行排序，然后选择最需要cpu的进程，也就是优先级高的，和等待cpu时间最长的进程来运行

那主要有哪些场景会触发进程调度呢？
- cpu是时间片，会被划分多个时间片，轮流的分配给进程，当某个进程时间片耗尽时，进程会被挂起，切换到其他正在等待cpu的进程运行
- 进程在系统资源不足时，需要等到资源满足后才可以运行进程，此时进程也会被挂起，并由系统调度其他进程运行
- 优先级搞得进程，较低的优先级进程会被挂起
- 主动挂起的进程 如 sleep，时间到了之后也会重新调度
- 硬件中断时，cpu上的进程也会被中断挂起，转而执行内核中的中断服务进程
```
# 线程上下文切换(线程是调度的基本单位，而进程是拥有资源的基本单位，切换的过程与进程上下文件切换一致)
```
内核态的任务调度，实际上调度的对象就是线程，而进程只是给线程提供了虚拟内存、全局变量等资源

进程只有一个线程时，可以理解两者没有什么区别
当进程有多个线程时，进程就比线程多了虚拟内存，全局变量等资源，而多个线程之间，这些资源他们是共享的，且上下文切换时它们是不需要被修改的，而线程也是有自己的私有资源的，比如栈和寄存器，这些独有的资源，在上下文切换时也是要被保存的，那进程间多线程切换就比进程内线程间切换资源消耗的多
```
